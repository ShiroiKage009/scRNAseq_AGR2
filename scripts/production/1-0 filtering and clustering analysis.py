# This script is meant for the processing of different files into a format that's ready for filtering by expression
# and downstream analyses. It writes the files containing cells identified by barcode and retrieved from the raw files and reprocessed
# This will read the files generated by "processing script.py"

# Import packages
import scanpy as sc
import anndata as ad
import pandas as pd

#%% function definitions
# The QC values used here are the same as script 0-0
def process_for_UMAP(data, normed = 0, leiden_res = 0.8):
    adata = data.copy() # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = 2000) # Filter cells based on minimum number of RNA reads
    sc.pp.filter_cells(adata, min_genes= 500) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = 3) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['predicted_doublets'] == False]
    adata_prefilt = adata_prefilt[adata_prefilt.obs['n_genes_by_counts'] < 8000]
    if not normed:
        adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < 50] # Filter on the cells with fewer than 10% mitochondrial reads
    else:
        adata_filt = adata_prefilt
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    print("################# Filtering on variable genes ... #################")
    adata_filt = adata_filt[:, adata_filt.var.highly_variable] # Filter on genes that are highly variable
    print("################# Regressing ... #################")
    sc.pp.regress_out(adata_filt, ['total_counts', 'pct_counts_mt']) # Regression. Not sure what that is.
    print("################# Scaling ... #################")
    sc.pp.scale(adata_filt, max_value = 10) # Scale the data
    print("################# Calculating PCA ... #################")
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt)
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt)
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res)
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt)
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga #################")
    sc.tl.umap(adata_filt, init_pos='paga')
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt)
    print("#################Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden'])
    return adata_filt

def recalc_UMAP(data, leiden_res = 0.8):
    adata_filt = data
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt)
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt)
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res)
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt)
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga#################")
    sc.tl.umap(adata_filt, init_pos='paga')
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt)
    print("################# Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden'])
    return adata_filt

def process_until_norm(data):
    adata = data.copy() # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = 2000) # Filter cells based on number of RNA reads
    sc.pp.filter_cells(adata, min_genes= 500) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = 3) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['predicted_doublets'] == False]
    adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < 50] # Filter on the cells with fewer than 10% mitochondrial reads
    adata_prefilt = adata_prefilt[adata_prefilt.obs['n_genes_by_counts'] < 8000]
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    return adata_filt
    

def isolate_cells_by_gene(data, gene, threshold):
    # Now subset_ant_mt_filt contains only the highly variable genes
    data_subset = data[data[:, gene].X > threshold]
    
    return data_subset

# This function filters the leiden clusters that are positivefor the gene you specify
# It assumes that you already did the differential expression analysis. 
# diff is boolean specifying if differential expresion is already done
# threshold is the threshold of expression
def filter_clusters_by_gene(data, gene, threshold = 0.5):
    # Load your AnnData object
    adata = data.copy()
    sc.tl.rank_genes_groups(adata, groupby='leiden', method = 'wilcoxon')
    # Extract the DataFrame for the differential expression results
    de_results = pd.DataFrame(adata.uns['rank_genes_groups']['names'])
    # Define a threshold for significant expression (adjust as needed)
    expression_threshold = threshold
    # Find clusters with significant EPCAM expression
    significant_clusters = []
    for cluster in de_results.columns:
        gene_presence = de_results[cluster].str.contains(gene)
        gene_expression = adata.uns['rank_genes_groups']['logfoldchanges'][cluster][gene_presence]
        if any(gene_expression >= expression_threshold):
            significant_clusters.append(cluster)
    # Subset the data to include only cells from the significant clusters
    adata_subset = adata[adata.obs['leiden'].isin(significant_clusters)].copy()
    return adata_subset

# This function maps things based on a specific column. Can use, for example, to rename the localizations to something that makes sense.
# You must define your map and feed it to the function separately.
# The default will be that it wors on the Localization column, but you can give it a different name later.

def map_to_column(data, map_set, column = 'Localization'):
    data.obs[column + '_old'] = data.obs[column]
    data.obs[column] = data.obs[column].map(map_set)
    print(data.obs[column])
    print(data.obs[column + '_old'])
    return 'Mapping function done'


#%% Environment settings and misc variables
sc.settings.verbosity = 3
sc.set_figure_params(dpi = 600)

inspect_stem = ['LGR5', 'MKI67', 'TNFRSF19', 'BMI1', 'LRIG1', 'leiden', 'Localization']
global_res = 0.5
LGR5_threshold = 0.5
diff_exp_method = 'wilcoxon'

#%% reading the already processed files
combined_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_proc.h5ad')
combined_nocol_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_nocol_proc.h5ad')
antrum_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/antrum_proc.h5ad')
combined_control_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_control_proc.h5ad')
combined_patient_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_patient_proc.h5ad')


#%% Gating on epithelial cells in the fully-combined file
combined_epithelium = filter_clusters_by_gene(data = combined_proc, gene = 'EPCAM')
antrum_epithelium = filter_clusters_by_gene(data = antrum_proc, gene = 'EPCAM')
nocol_epithelium = filter_clusters_by_gene(data = combined_nocol_proc, gene = 'EPCAM')
combined_control_epithelium = filter_clusters_by_gene(data = combined_control_proc, gene = 'EPCAM')
combined_patient_epithelium = filter_clusters_by_gene(data = combined_patient_proc, gene = 'EPCAM')

#%% QC check plots
#sc.pl.umap(combined_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')
#sc.pl.umap(antrum_epithelium, color = ['leiden', 'Localization'], title = 'antrum_epithelium QC')
#sc.pl.umap(nocol_epithelium, color = ['leiden', 'Localization'], title = 'nocol_epithelium QC')
#sc.pl.umap(combined_control_epithelium, color = ['leiden', 'Localization'], title = 'combined_control_epithelium QC')
#sc.pl.umap(combined_patient_epithelium, color = ['leiden', 'Localization'], title = 'combined_patient_epithelium QC')


#%% Relabeling Localization
# Preparing the index 
localization_mapping = {
    'Antrum GI6253' : 'Control Antrum',
    'Antrum P26' : 'P1 Antrum',
    'Colon GI6253' : 'Control Colon',
    'Colon P26' : 'P1 Colon',
    'Duodenum GI6253' : 'Control Duodenum',
    'Duodenum P26' : 'P1 Duodenum'
}

# Doing the mapping
# The combined dataset
map_to_column(combined_epithelium, map_set = localization_mapping, column = 'Localization')

# The antrum dataset
map_to_column(data = antrum_epithelium, map_set = localization_mapping, column = 'Localization')

# The combined no colon dataset
map_to_column(data = nocol_epithelium, map_set = localization_mapping, column = 'Localization')

# The combined control only
map_to_column(data = combined_control_epithelium, map_set = localization_mapping, column = 'Localization')

#%% Filtering and combining the LGR5 and MKI67 cells from all the different epithelial combinations
# Filtering combined
combined_ep_LGR5 = isolate_cells_by_gene(data = combined_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_ep_MKI67 = isolate_cells_by_gene(data = combined_epithelium, gene = 'MKI67', threshold = 0.5)
combined_nu_LGR5MKI67 = ad.concat([combined_ep_LGR5, combined_ep_MKI67], join = 'outer')
combined_LGR5MKI67 = combined_nu_LGR5MKI67[~combined_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering antrum
antrum_ep_LGR5 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
antrum_ep_MKI67 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'MKI67', threshold = 0.5)
antrum_nu_LGR5MKI67 = ad.concat([antrum_ep_LGR5, antrum_ep_MKI67], join = 'outer')
antrum_LGR5MKI67 = antrum_nu_LGR5MKI67[~antrum_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined no colon
nocol_ep_LGR5 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
nocol_ep_MKI67 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'MKI67', threshold = 0.5)
nocol_nu_LGR5MKI67 = ad.concat([nocol_ep_LGR5, nocol_ep_MKI67], join = 'outer')
nocol_LGR5MKI67 = nocol_nu_LGR5MKI67[~nocol_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined control only
combined_control_ep_LGR5 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_control_ep_MKI67 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'MKI67', threshold = 0.5)
combined_control_nu_LGR5MKI67 = ad.concat([combined_control_ep_LGR5, combined_control_ep_MKI67], join = 'outer')
combined_control_LGR5MKI67 = combined_control_nu_LGR5MKI67[~combined_control_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

#%% Recalculating UMAPs of the different combinations
combined_LGR5_recalc = recalc_UMAP(data = combined_ep_LGR5, leiden_res = 0.1)
combined_MKI67_recalc = recalc_UMAP(data = combined_ep_MKI67, leiden_res = 0.1)

antrum_LGR5_recalc = recalc_UMAP(data = antrum_ep_LGR5, leiden_res = 0.1)
antrum_MKI67_recalc = recalc_UMAP(data = antrum_ep_MKI67, leiden_res = 0.1)

nocol_LGR5_recalc = recalc_UMAP(data = nocol_ep_LGR5, leiden_res = 0.5)
nocol_MKI67_recalc = recalc_UMAP(data = nocol_ep_MKI67, leiden_res = 0.5)

combined_control_LGR5_recalc = recalc_UMAP(data = combined_control_ep_LGR5, leiden_res = 0.5)
combined_control_MKI67_recalc = recalc_UMAP(data = combined_control_ep_MKI67, leiden_res = 0.5)

combined_LGR5MKI67_recalc = recalc_UMAP(data = combined_LGR5MKI67, leiden_res = 0.1)
nocol_LGR5MKI67_recalc = recalc_UMAP(data = nocol_LGR5MKI67, leiden_res = 0.1)
antrum_LGR5MKI67_recalc = recalc_UMAP(data = antrum_LGR5MKI67, leiden_res = 0.05)
combined_control_LGR5MKI67_recalc = recalc_UMAP(data = combined_control_LGR5MKI67, leiden_res = 0.1)

# =============================================================================
print("######################################################################")
print("####   END OF PROCESSING. START MESSING AROUND WITH ANALYSIS.     ####")
print("######################################################################")
# =============================================================================
#%% Plotting Checking all the different QC metrics in obs post processing just to make sure things are proper
checking = ['Biopsies', 'Inflammation', 'pct_counts_mt', 'pct_counts_rp', 'pct_counts_hb', 'n_genes', 'doublet_scores', 'Localization']
str(combined_epithelium)
#sc.pl.umap(combined_LGR5_recalc, color = checking) 
#sc.pl.umap(antrum_LGR5_recalc, color = checking) 
#sc.pl.umap(combined_epithelium, color = checking)
#sc.pl.umap(combined_epithelium, color = checking)
#sc.pl.umap(nocol_epithelium, color = 'Localization', size = 10)
print(antrum_epithelium.obs['Patient'].value_counts())
 
#%% Plotting the UMAPs from above to check
#sc.pl.umap(combined_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined MKI67')

#sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5')
#sc.pl.umap(antrum_MKI67_recalc, color = inspect_stem, size = 90, title = 'antrum MKI67')

#sc.pl.umap(nocol_LGR5_recalc, color = inspect_stem, size = 30, title = 'nocol LGR5')
#sc.pl.umap(nocol_MKI67_recalc, color = inspect_stem, size = 30, title = 'nocol MKI67')

#sc.pl.umap(combined_control_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined_control LGR5')
#sc.pl.umap(combined_control_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined_control MKI67')

#sc.pl.umap(combined_LGR5MKI67_recalc, color = inspect_stem, size = 5, title = 'LGR5/combined prolif')
#sc.pl.umap(antrum_LGR5MKI67_recalc, color = inspect_stem, size = 60, title = 'LGR5/antrum prolif')
#sc.pl.umap(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')
#sc.pl.tsne(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')

#%% Inspecting the clusters vs localization to check
#sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined MKI67')

#sc.pl.umap(antrum_LGR5_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum LGR5')
#sc.pl.umap(antrum_MKI67_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum MKI67')

#sc.pl.umap(nocol_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol LGR5')
#sc.pl.umap(nocol_MKI67_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol MKI67')

#sc.pl.umap(combined_control_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined_control LGR5')
#sc.pl.umap(combined_control_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined_control MKI67')

#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined prolif')
#sc.pl.umap(antrum_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 60, title = 'LGR5/antrum prolif')
#sc.pl.umap(nocol_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 10, title = 'LGR5/nocol prolif')
#sc.pl.umap(combined_control_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined_control prolif')


#%% mapping for antrum LGR5 
#sc.pl.umap(antrum_LGR5_recalc, color = ['leiden'], size = 70, title = 'antrum LGR5')
#sc.pl.umap(antrum_LGR5_recalc, color = ['Localization'], size = 70, title = 'antrum LGR5')

# Define a dictionary mapping the old cluster numbers to the new labels
ant_LGR5_mapping = {
    '0' : "Gastric antrum",
    '1' : "Metaplastic antrum"
}

# Convert the cluster numbers to labels using the mapping
antrum_LGR5_recalc.obs['leiden'] = antrum_LGR5_recalc.obs['leiden'].map(ant_LGR5_mapping)

# Rename the leiden column into something that makes sense
# =============================================================================
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)
# =============================================================================

# Print the first few rows to verify the changes
print(antrum_LGR5_recalc.obs.head())

#sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'leiden'], size = 150, title = 'LGR5+ cells')
#sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'Localization'], size = 150, title = 'LGR5+ cells')
#sc.pl.violin(antrum_LGR5_recalc, keys = 'HSPA5', groupby = 'Localization')


#sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5 2')
sc.tl.rank_genes_groups(antrum_LGR5_recalc, groupby='leiden', method = 'wilcoxon')
#sc.pl.rank_genes_groups(antrum_LGR5_recalc, n_genes=25)

#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'AQP5', 'SLC39A5', 'leiden', 'Localization'], size = 90)

#sc.pl.umap(antrum_LGR5_recalc, color = 'leiden', size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = 'Localization', size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'leiden'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells
#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'LGR5'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells

#sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)

#sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
#sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)


#%% mapping for combined MKI67 
#sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 5, title = 'combined MKI67')
#sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 5, title = 'combined MKI67')

# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "?"
}

# Convert the cluster numbers to labels using the mapping
combined_MKI67_recalc.obs['leiden'] = combined_MKI67_recalc.obs['leiden'].map(cluster_mapping)

# Optionally, if you want to rename the column to reflect the new labels
combined_MKI67_recalc.obs['leiden'].name = 'Cell Type'

# Print the first few rows to verify the changes
print(combined_MKI67_recalc.obs.head())

#sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 7, title = 'MKI67+ cells')
#sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 7, title = 'MKI67+ cells')
#sc.pl.violin(combined_MKI67_recalc, keys = 'HSPA5', groupby = 'Localization', rotation = 90)

#%% mapping for combined LGR5 
#sc.pl.umap(combined_LGR5_recalc, color = ['leiden'], size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 15, title = 'combined LGR5')

# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "3"
}

# Convert the cluster numbers to labels using the mapping
combined_LGR5_recalc.obs['leiden'] = combined_LGR5_recalc.obs['leiden'].map(cluster_mapping)

# Rename the leiden column into something that makes sense
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)


# Print the first few rows to verify the changes
print(combined_LGR5_recalc.obs.head())

#sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'LGR5+ cells')
#sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 30, title = 'LGR5+ cells')

#%% test cells
#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['HSPA5', 'MKI67', 'LGR5', 'leiden', 'Localization'], size = 5)
separated_combo = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].copy()
separated_combo_2 = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'GI6253'].copy()
#sc.pl.umap(separated_combo, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
#sc.pl.scatter(separated_combo, x = 'MKI67', y = 'HSPA5', size = 90, color = 'LGR5')
#sc.pl.scatter(separated_combo, x = 'LGR5', y = 'HSPA5', size = 90, color = 'MKI67')
#sc.pl.scatter(separated_combo, x = 'LGR5', y = 'MKI67', size = 90, color = 'HSPA5')

#sc.pl.violin(separated_combo, keys = 'HSPA5', groupby = 'Site')
#sc.pl.violin(separated_combo_2, keys = 'HSPA5', groupby = 'Site')

#sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'MKI67', y = 'HSPA5', size = 90, color = 'Localization')
#sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'LGR5', y = 'HSPA5', size = 90, color = 'Localization')

print(separated_combo.obs['Localization'])

#%% Test cell 2

#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
indices_of_interest = combined_LGR5MKI67_recalc.obs[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].index.copy()
sep = combined_LGR5MKI67_recalc[indices_of_interest]
#sc.pl.umap(sep, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])


#%% Writing the files for volcano plot in R. This is specifically for antrum_LGR5_recalc
# Extract the relevant arrays
gene_names = antrum_LGR5_recalc.uns['rank_genes_groups']['names']
logfoldchanges = antrum_LGR5_recalc.uns['rank_genes_groups']['logfoldchanges']
pvals_adj = antrum_LGR5_recalc.uns['rank_genes_groups']['pvals_adj']

# Since you have two groups, you can loop or manually index each group
# Assuming group names are '0' and '1', adjust accordingly

dataframes = {}
for group in ['Gastric antrum', 'Metaplastic antrum']:
    # Extract information for each group
    names = gene_names[group]
    lfc = logfoldchanges[group]
    pval_adj = pvals_adj[group]

    # Create DataFrame
    df = pd.DataFrame({
        'Gene Names': names,
        'Log Fold Change': lfc,
        'Adjusted P-Value': pval_adj
    }).set_index('Gene Names')

    dataframes[group] = df

# Now you have two DataFrames in the `dataframes` dict, one for each group
# Access them like this:
control_ant = dataframes['Gastric antrum']
metaplastic_ant = dataframes['Metaplastic antrum']

control_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/control_ant.csv')
metaplastic_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/metaplastic_ant.csv')

#%% Extracting the barcodes of the filtered cells so we can retrieve their raw values

# Start by reading the barcodes
# LGR5
antrum_LGR5_barcodes = antrum_LGR5_recalc.obs_names.tolist()
nocol_LGR5_barcodes = nocol_LGR5_recalc.obs_names.tolist()
combined_LGR5_barcodes = combined_LGR5_recalc.obs_names.tolist()
# Epithelium
antrum_barcodes = antrum_epithelium.obs_names.tolist()
nocol_barcodes = nocol_epithelium.obs_names.tolist()
combined_barcodes = combined_epithelium.obs_names.tolist()

# Reading the original files
ant_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_antrum.h5ad")
duo_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_duodenum.h5ad")
col_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_colon.h5ad")
combined_unfilt = ad.concat([ant_unfilt, duo_unfilt, col_unfilt], join = 'outer')
nocol_unfilt = ad.concat([duo_unfilt, ant_unfilt], join = 'outer')

# Subsetting
# LGR5
antrum_LGR5_unfilt_subset = ant_unfilt[antrum_LGR5_barcodes].copy()
combined_LGR5_unfilt_subset = combined_unfilt[combined_LGR5_barcodes].copy()
nocol_LGR5_unfilt_subset = nocol_unfilt[nocol_LGR5_barcodes].copy()
# Epithelium
antrum_unfilt_subset = ant_unfilt[antrum_barcodes].copy()
combined_unfilt_subset = combined_unfilt[combined_barcodes].copy()
nocol_unfilt_subset = nocol_unfilt[nocol_barcodes].copy()

#sc.pl.violin(combined_unfilt_subset, keys = 'n_genes_by_counts', groupby = 'Patient')
#sc.pl.scatter(combined_unfilt_subset, y = 'n_genes_by_counts', x = 'LGR5', color = 'Patient')
#combined_unfilt_subset.obs['Patient'].value_counts()

#%% Processing and plotting the filtered stuff from raw instead of all the resdone stuff
# For the combined
# LGR5
combined_LGR5_refilt_proc = process_for_UMAP(combined_LGR5_unfilt_subset, leiden_res = 0.1)
combined_LGR5_refilt_proc.obs['Localization'] = combined_LGR5_refilt_proc.obs['Site'].astype(str) + ' ' + combined_LGR5_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(combined_LGR5_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 20)
# Epithelium
combined_refilt_proc = process_for_UMAP(combined_unfilt_subset, leiden_res = 0.1)
combined_refilt_proc.obs['Localization'] = combined_refilt_proc.obs['Site'].astype(str) + ' ' + combined_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(combined_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 20)


# For antrum
# LGR5
antrum_LGR5_refilt_proc = process_for_UMAP(antrum_LGR5_unfilt_subset, leiden_res = 0.3)
antrum_LGR5_refilt_proc.obs['Localization'] = antrum_LGR5_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_LGR5_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(antrum_LGR5_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
# Epithelium
antrum_refilt_proc = process_for_UMAP(antrum_unfilt_subset, leiden_res = 0.3)
antrum_refilt_proc.obs['Localization'] = antrum_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(antrum_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
# Patient



# For nocol
# LGR5
nocol_LGR5_refilt_proc = process_for_UMAP(nocol_LGR5_unfilt_subset, leiden_res = 0.1)
nocol_LGR5_refilt_proc.obs['Localization'] = nocol_LGR5_refilt_proc.obs['Site'].astype(str) + ' ' + nocol_LGR5_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(nocol_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 40)
# Epithelium
nocol_refilt_proc = process_for_UMAP(nocol_unfilt_subset, leiden_res = 0.1)
nocol_refilt_proc.obs['Localization'] = nocol_refilt_proc.obs['Site'].astype(str) + ' ' + nocol_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(nocol_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 40)

sc.pl.violin(antrum_refilt_proc, keys = 'n_genes_by_counts', groupby = 'Patient')
sc.pl.scatter(antrum_refilt_proc, y = 'n_genes_by_counts', x = 'LGR5', color = 'Patient')
antrum_refilt_proc.obs['Patient'].value_counts()

#%%
# Writing the refiltered and processed files
combined_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_refilt_proc.h5ad')
antrum_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_refilt_proc.h5ad')
combined_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_LGR5_refilt_proc.h5ad')
antrum_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_LGR5_refilt_proc.h5ad')
nocol_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_LGR5_refilt_proc.h5ad')
nocol_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_refilt_proc.h5ad')


#%%
sc.pl.umap(antrum_refilt_proc, color = ['ANPEP', 'MUC2', 'LGR5', 'MKI67', 'leiden', 'Localization'])

#%%