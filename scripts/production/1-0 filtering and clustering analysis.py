# This script is meant for the processing of different files into a format that's ready for filtering by expression
# and downstream analyses. It writes the files containing cells identified by barcode and retrieved from the raw files and reprocessed
# This will read the files generated by "processing script.py"

# Import packages
import scanpy as sc
import anndata as ad
import pandas as pd
import time

def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} executed in {end_time - start_time} seconds")
        return result
    return wrapper

# DEFAULT QC VALUES. Calibrated to Sarah Teichmann's paper "Cells of the human intestinal tract mapped across space and time." These QC values will apply by default for this entire script.
def filter_cells_for_UMAP(data, min_ct = 2000, min_gen = 500, min_cell = 3, mt_pct = 60, max_genes = 0, normed = 0, d_score = 0.24): 
    adata = data # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = min_ct) # Filter cells based on number of RNA reads
    sc.pp.filter_cells(adata, min_genes= min_gen) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = min_cell) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['doublet_scores'] < 0.24]
    if max_genes > 0:
        adata_prefilt = adata_prefilt[adata_prefilt.obs['n_genes_by_counts'] < max_genes]
        
    if not normed:
        adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < mt_pct] # Filtering based on percentage of mitochondrial genes
    else:
        adata_filt = adata_prefilt
    return adata_filt    

def process_for_UMAP(data, leiden_res = 0.8, filtering = 1, min_ct = 2000, min_gen = 500, min_cell = 3, mt_pct = 60, max_genes = 0, normed = 0, d_score = 0.24): # DEFAULT QC VALUES
    adata = data # This is to avoid writing into the file that's entered as an argument
    if filtering:
        adata_filt = filter_cells_for_UMAP(data = adata, min_ct = min_ct, min_gen = min_gen, min_cell = min_cell, max_genes = max_genes, mt_pct = mt_pct, d_score = d_score)
    else:
        adata_filt = adata       
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    print("################# Filtering on variable genes ... #################")
    adata_filt = adata_filt[:, adata_filt.var.highly_variable] # Filter on genes that are highly variable
    print("################# Regressing ... #################")
    sc.pp.regress_out(adata_filt, ['total_counts', 'pct_counts_mt']) # Regression. Not sure what that is.
    print("################# Scaling ... #################")
    sc.pp.scale(adata_filt, max_value = 10) # Scale the data
    print("################# Calculating PCA ... #################")
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt) # Calculate tsne
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt) # Calculate neighbors
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res) # Calculate Leiden clusters
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt) # Calculate PAGA
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga #################")
    sc.tl.umap(adata_filt, init_pos='paga') # Plot PAGA
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt) # Calculate UMAP
    print("#################Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden']) # Plot UMAP and show Leiden clusters
    return adata_filt
#######################################################
################## FUNCTION DEF END ###################
#######################################################
    return adata_filt

@time_it
def recalc_UMAP(data, leiden_res = 0.8):
    adata_filt = data
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt)
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt)
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res)
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt)
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga#################")
    sc.tl.umap(adata_filt, init_pos='paga')
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt)
    print("################# Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden'])
    return adata_filt

@time_it
def process_until_norm(data):
    adata = data.copy() # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = 2000) # Filter cells based on number of RNA reads
    sc.pp.filter_cells(adata, min_genes= 500) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = 3) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['doublet_scores'] < 0.24]
    adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < 60] # Filter on the cells with fewer than 10% mitochondrial reads
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    return adata_filt
    

def isolate_cells_by_gene(data, gene, threshold):
    # Now subset_ant_mt_filt contains only the highly variable genes
    data_subset = data[data[:, gene].X > threshold]
    
    return data_subset

# This function filters the leiden clusters that are positivefor the gene you specify
# It assumes that you already did the differential expression analysis. 
# diff is boolean specifying if differential expresion is already done
# threshold is the threshold of expression
def filter_clusters_by_gene(data, gene, threshold = 0.5):
    # Load your AnnData object
    adata = data.copy()
    sc.tl.rank_genes_groups(adata, groupby='leiden', method = 'wilcoxon')
    # Extract the DataFrame for the differential expression results
    de_results = pd.DataFrame(adata.uns['rank_genes_groups']['names'])
    # Define a threshold for significant expression (adjust as needed)
    expression_threshold = threshold
    # Find clusters with significant EPCAM expression
    significant_clusters = []
    for cluster in de_results.columns:
        gene_presence = de_results[cluster].str.contains(gene)
        gene_expression = adata.uns['rank_genes_groups']['logfoldchanges'][cluster][gene_presence]
        if any(gene_expression >= expression_threshold):
            significant_clusters.append(cluster)
    # Subset the data to include only cells from the significant clusters
    adata_subset = adata[adata.obs['leiden'].isin(significant_clusters)].copy()
    return adata_subset

# This function maps things based on a specific column. Can use, for example, to rename the localizations to something that makes sense.
# You must define your map and feed it to the function separately.
# The default will be that it wors on the Localization column, but you can give it a different name later.

def map_to_column(data, map_set, column = 'Localization'):
    data.obs[column + '_old'] = data.obs[column]
    data.obs[column] = data.obs[column].map(map_set)
    print(data.obs[column])
    print(data.obs[column + '_old'])
    return 'Mapping function done'

#replace_with_%%_to_restore_cell_breaks Start timer
start_time = time.time()

#replace_with_%%_to_restore_cell_breaks Environment settings and misc variables
sc.settings.verbosity = 3
sc.set_figure_params(dpi = 600)

inspect_stem = ['LGR5', 'MKI67', 'TNFRSF19', 'BMI1', 'LRIG1', 'leiden', 'Localization']
inspect_wnt = ['WNT1', 'WNT2', 'WNT2B', 'WNT3A', 'WNT4', 'WNT5A', 'WNT6', 'WNT9A', 'WNT9B', 'WNT10B', 'WNT11', 'WNT16B']
global_res = 0.5
LGR5_threshold = 0.1
diff_exp_method = 'wilcoxon'


#replace_with_%%_to_restore_cell_breaks reading the already processed files
combined_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_proc.h5ad')
combined_nocol_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_nocol_proc.h5ad')
antrum_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/antrum_proc.h5ad')
combined_control_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_control_proc.h5ad')
combined_patient_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_patient_proc.h5ad')
duodenum_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/duodenum_combined.h5ad')

#replace_with_%%_to_restore_cell_breaks Gating on epithelial cells in the fully-combined file
combined_epithelium = filter_clusters_by_gene(data = combined_proc, gene = 'EPCAM')
antrum_epithelium = filter_clusters_by_gene(data = antrum_proc, gene = 'EPCAM')
nocol_epithelium = filter_clusters_by_gene(data = combined_nocol_proc, gene = 'EPCAM')
combined_control_epithelium = filter_clusters_by_gene(data = combined_control_proc, gene = 'EPCAM')
combined_patient_epithelium = filter_clusters_by_gene(data = combined_patient_proc, gene = 'EPCAM')
duodenum_epithelium = filter_clusters_by_gene(data = duodenum_proc, gene = 'EPCAM')

#replace_with_%%_to_restore_cell_breaks QC check plots
#sc.pl.umap(combined_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')
#sc.pl.umap(antrum_epithelium, color = ['leiden', 'Localization'], title = 'antrum_epithelium QC')
#sc.pl.umap(nocol_epithelium, color = ['leiden', 'Localization'], title = 'nocol_epithelium QC')
#sc.pl.umap(combined_control_epithelium, color = ['leiden', 'Localization'], title = 'combined_control_epithelium QC')
#sc.pl.umap(combined_patient_epithelium, color = ['leiden', 'Localization'], title = 'combined_patient_epithelium QC')


#break Relabeling Localization
# Preparing the index 
localization_mapping = {
    'Antrum GI6253' : 'Control Antrum',
    'Antrum P26' : 'P1 Antrum',
    'Colon GI6253' : 'Control Colon',
    'Colon P26' : 'P1 Colon',
    'Duodenum GI6253' : 'Control Duodenum',
    'Duodenum P26' : 'P1 Duodenum'
}

# Doing the mapping
# The combined dataset
map_to_column(combined_epithelium, map_set = localization_mapping, column = 'Localization')
# The antrum dataset
map_to_column(data = antrum_epithelium, map_set = localization_mapping, column = 'Localization')
# The combined no colon dataset
map_to_column(data = nocol_epithelium, map_set = localization_mapping, column = 'Localization')
# The combined control only
map_to_column(data = combined_control_epithelium, map_set = localization_mapping, column = 'Localization')
# The combined duodenum
map_to_column(data = duodenum_epithelium, map_set = localization_mapping, column = 'Localization')

#%% Filtering and combining the LGR5 and MKI67 cells from all the different epithelial combinations
# Filtering combined
combined_ep_LGR5 = isolate_cells_by_gene(data = combined_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_ep_MKI67 = isolate_cells_by_gene(data = combined_epithelium, gene = 'MKI67', threshold = 0.5)
combined_nu_LGR5MKI67 = ad.concat([combined_ep_LGR5, combined_ep_MKI67], join = 'outer')
combined_LGR5MKI67 = combined_nu_LGR5MKI67[~combined_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering antrum
antrum_ep_LGR5 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
antrum_ep_MKI67 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'MKI67', threshold = 0.5)
antrum_nu_LGR5MKI67 = ad.concat([antrum_ep_LGR5, antrum_ep_MKI67], join = 'outer')
antrum_LGR5MKI67 = antrum_nu_LGR5MKI67[~antrum_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined no colon
nocol_ep_LGR5 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
nocol_ep_MKI67 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'MKI67', threshold = 0.5)
nocol_nu_LGR5MKI67 = ad.concat([nocol_ep_LGR5, nocol_ep_MKI67], join = 'outer')
nocol_LGR5MKI67 = nocol_nu_LGR5MKI67[~nocol_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined control only
combined_control_ep_LGR5 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_control_ep_MKI67 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'MKI67', threshold = 0.5)
combined_control_nu_LGR5MKI67 = ad.concat([combined_control_ep_LGR5, combined_control_ep_MKI67], join = 'outer')
combined_control_LGR5MKI67 = combined_control_nu_LGR5MKI67[~combined_control_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering duodenum only
duo_ep_LGR5 = isolate_cells_by_gene(data = duodenum_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
duo_ep_MKI67 = isolate_cells_by_gene(data = duodenum_epithelium, gene = 'MKI67', threshold = 0.5)
duo_nu_LGR5MKI67 = ad.concat([duo_ep_LGR5, duo_ep_MKI67], join = 'outer')
duoduo_LGR5MKI67 = duo_nu_LGR5MKI67[~duo_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

#%% Recalculating UMAPs of the different combinations
combined_LGR5_recalc = recalc_UMAP(data = combined_ep_LGR5, leiden_res = 0.1)
combined_MKI67_recalc = recalc_UMAP(data = combined_ep_MKI67, leiden_res = 0.1)

antrum_LGR5_recalc = recalc_UMAP(data = antrum_ep_LGR5, leiden_res = 0.1)
antrum_MKI67_recalc = recalc_UMAP(data = antrum_ep_MKI67, leiden_res = 0.1)

nocol_LGR5_recalc = recalc_UMAP(data = nocol_ep_LGR5, leiden_res = 0.5)
nocol_MKI67_recalc = recalc_UMAP(data = nocol_ep_MKI67, leiden_res = 0.5)

combined_control_LGR5_recalc = recalc_UMAP(data = combined_control_ep_LGR5, leiden_res = 0.5)
combined_control_MKI67_recalc = recalc_UMAP(data = combined_control_ep_MKI67, leiden_res = 0.5)

duo_LGR5_recalc = recalc_UMAP(data = duo_ep_LGR5, leiden_res = 0.5)
duo_MNKI67_recalc = recalc_UMAP(data = duo_ep_MKI67, leiden_res = 0.5)

combined_LGR5MKI67_recalc = recalc_UMAP(data = combined_LGR5MKI67, leiden_res = 0.1)
nocol_LGR5MKI67_recalc = recalc_UMAP(data = nocol_LGR5MKI67, leiden_res = 0.1)
antrum_LGR5MKI67_recalc = recalc_UMAP(data = antrum_LGR5MKI67, leiden_res = 0.05)
combined_control_LGR5MKI67_recalc = recalc_UMAP(data = combined_control_LGR5MKI67, leiden_res = 0.1)

# =============================================================================
print("######################################################################")
print("####   END OF PROCESSING. START MESSING AROUND WITH ANALYSIS.     ####")
print("######################################################################")
# =============================================================================

#%% Plotting Checking all the different QC metrics in obs post processing just to make sure things are proper
checking = ['Biopsies', 'Inflammation', 'pct_counts_mt', 'pct_counts_rp', 'pct_counts_hb', 'n_genes', 'doublet_scores', 'Localization']
str(combined_epithelium)
#sc.pl.umap(combined_LGR5_recalc, color = checking) 
#sc.pl.umap(antrum_LGR5_recalc, color = checking) 
#sc.pl.umap(combined_epithelium, color = checking)
#sc.pl.umap(combined_epithelium, color = checking)
#sc.pl.umap(nocol_epithelium, color = 'Localization', size = 10)
print(antrum_epithelium.obs['Patient'].value_counts())
 
#replace_with_%%_to_restore_cell_breaks Plotting the UMAPs from above to check
#sc.pl.umap(combined_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined MKI67')

#sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5')
#sc.pl.umap(antrum_MKI67_recalc, color = inspect_stem, size = 90, title = 'antrum MKI67')

#sc.pl.umap(nocol_LGR5_recalc, color = inspect_stem, size = 30, title = 'nocol LGR5')
#sc.pl.umap(nocol_MKI67_recalc, color = inspect_stem, size = 30, title = 'nocol MKI67')

#sc.pl.umap(combined_control_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined_control LGR5')
#sc.pl.umap(combined_control_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined_control MKI67')

#sc.pl.umap(combined_LGR5MKI67_recalc, color = inspect_stem, size = 5, title = 'LGR5/combined prolif')
#sc.pl.umap(antrum_LGR5MKI67_recalc, color = inspect_stem, size = 60, title = 'LGR5/antrum prolif')
#sc.pl.umap(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')
#sc.pl.tsne(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')

#replace_with_%%_to_restore_cell_breaks Inspecting the clusters vs localization to check
#sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined MKI67')

#sc.pl.umap(antrum_LGR5_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum LGR5')
#sc.pl.umap(antrum_MKI67_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum MKI67')

#sc.pl.umap(nocol_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol LGR5')
#sc.pl.umap(nocol_MKI67_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol MKI67')

#sc.pl.umap(combined_control_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined_control LGR5')
#sc.pl.umap(combined_control_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined_control MKI67')

#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined prolif')
#sc.pl.umap(antrum_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 60, title = 'LGR5/antrum prolif')
#sc.pl.umap(nocol_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 10, title = 'LGR5/nocol prolif')
#sc.pl.umap(combined_control_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined_control prolif')


#replace_with_%%_to_restore_cell_breaks mapping for antrum LGR5 
#sc.pl.umap(antrum_LGR5_recalc, color = ['leiden'], size = 70, title = 'antrum LGR5')
#sc.pl.umap(antrum_LGR5_recalc, color = ['Localization'], size = 70, title = 'antrum LGR5')

#%%
# Define a dictionary mapping the old cluster numbers to the new labels
ant_LGR5_mapping = {
    '0' : "Gastric antrum",
    '1' : "Metaplastic antrum"
}

# Convert the cluster numbers to labels using the mapping
antrum_LGR5_recalc.obs['leiden'] = antrum_LGR5_recalc.obs['leiden'].map(ant_LGR5_mapping)

# Rename the leiden column into something that makes sense
# =============================================================================
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)
# =============================================================================

# Print the first few rows to verify the changes
print(antrum_LGR5_recalc.obs.head())

#sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'leiden'], size = 150, title = 'LGR5+ cells')
#sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'Localization'], size = 150, title = 'LGR5+ cells')
#sc.pl.violin(antrum_LGR5_recalc, keys = 'HSPA5', groupby = 'Localization')


#sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5 2')
sc.tl.rank_genes_groups(antrum_LGR5_recalc, groupby='leiden', method = 'wilcoxon')
#sc.pl.rank_genes_groups(antrum_LGR5_recalc, n_genes=25)

#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'AQP5', 'SLC39A5', 'leiden', 'Localization'], size = 90)

#sc.pl.umap(antrum_LGR5_recalc, color = 'leiden', size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = 'Localization', size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'leiden'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells
#sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'LGR5'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells

#sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
#sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)

#sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
#sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)


#replace_with_%%_to_restore_cell_breaks mapping for combined MKI67 
#sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 5, title = 'combined MKI67')
#sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 5, title = 'combined MKI67')

#%%
# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "?"
}

# Convert the cluster numbers to labels using the mapping
combined_MKI67_recalc.obs['leiden'] = combined_MKI67_recalc.obs['leiden'].map(cluster_mapping)

# Optionally, if you want to rename the column to reflect the new labels
combined_MKI67_recalc.obs['leiden'].name = 'Cell Type'

# Print the first few rows to verify the changes
print(combined_MKI67_recalc.obs.head())

#sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 7, title = 'MKI67+ cells')
#sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 7, title = 'MKI67+ cells')
#sc.pl.violin(combined_MKI67_recalc, keys = 'HSPA5', groupby = 'Localization', rotation = 90)

#replace_with_%%_to_restore_cell_breaks mapping for combined LGR5 
#sc.pl.umap(combined_LGR5_recalc, color = ['leiden'], size = 15, title = 'combined LGR5')
#sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 15, title = 'combined LGR5')

#break
# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "3"
}

# Convert the cluster numbers to labels using the mapping
combined_LGR5_recalc.obs['leiden'] = combined_LGR5_recalc.obs['leiden'].map(cluster_mapping)

# Rename the leiden column into something that makes sense
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)


# Print the first few rows to verify the changes
print(combined_LGR5_recalc.obs.head())

#sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'LGR5+ cells')
#sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 30, title = 'LGR5+ cells')

#replace_with_%%_to_restore_cell_breaks test cells
#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['HSPA5', 'MKI67', 'LGR5', 'leiden', 'Localization'], size = 5)
separated_combo = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].copy()
separated_combo_2 = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'GI6253'].copy()
#sc.pl.umap(separated_combo, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
#sc.pl.scatter(separated_combo, x = 'MKI67', y = 'HSPA5', size = 90, color = 'LGR5')
#sc.pl.scatter(separated_combo, x = 'LGR5', y = 'HSPA5', size = 90, color = 'MKI67')
#sc.pl.scatter(separated_combo, x = 'LGR5', y = 'MKI67', size = 90, color = 'HSPA5')

#sc.pl.violin(separated_combo, keys = 'HSPA5', groupby = 'Site')
#sc.pl.violin(separated_combo_2, keys = 'HSPA5', groupby = 'Site')

#sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'MKI67', y = 'HSPA5', size = 90, color = 'Localization')
#sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'LGR5', y = 'HSPA5', size = 90, color = 'Localization')

print(separated_combo.obs['Localization'])

#replace_with_%%_to_restore_cell_breaks Test cell 2

#sc.pl.umap(combined_LGR5MKI67_recalc, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
indices_of_interest = combined_LGR5MKI67_recalc.obs[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].index.copy()
sep = combined_LGR5MKI67_recalc[indices_of_interest]
#sc.pl.umap(sep, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])


#%% Extracting the barcodes of the filtered cells so we can retrieve their raw values

# Start by reading the barcodes
# LGR5
antrum_LGR5_barcodes = antrum_LGR5_recalc.obs_names.tolist()
nocol_LGR5_barcodes = nocol_LGR5_recalc.obs_names.tolist()
combined_LGR5_barcodes = combined_LGR5_recalc.obs_names.tolist()
duo_LGR5_barcodes = duo_LGR5_recalc.obs_names.tolist()
# Epithelium
antrum_barcodes = antrum_epithelium.obs_names.tolist()
nocol_barcodes = nocol_epithelium.obs_names.tolist()
combined_barcodes = combined_epithelium.obs_names.tolist()
duodenum_barcodes = duodenum_epithelium.obs_names.tolist()

# Reading the original files
ant_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_antrum.h5ad")
duo_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_duodenum.h5ad")
col_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_colon.h5ad")
combined_unfilt = ad.concat([ant_unfilt, duo_unfilt, col_unfilt], join = 'outer')
nocol_unfilt = ad.concat([duo_unfilt, ant_unfilt], join = 'outer')

# Adding Localization column
ant_unfilt.obs['Localization'] = ant_unfilt.obs['Site'].astype(str) + ' ' + ant_unfilt.obs['Patient'].astype(str)
duo_unfilt.obs['Localization'] = duo_unfilt.obs['Site'].astype(str) + ' ' + duo_unfilt.obs['Patient'].astype(str)
col_unfilt.obs['Localization'] = col_unfilt.obs['Site'].astype(str) + ' ' + col_unfilt.obs['Patient'].astype(str)
combined_unfilt.obs['Localization'] = combined_unfilt.obs['Site'].astype(str) + ' ' + combined_unfilt.obs['Patient'].astype(str)

# Subsetting
# LGR5
antrum_LGR5_unfilt_subset = ant_unfilt[antrum_LGR5_barcodes].copy()
combined_LGR5_unfilt_subset = combined_unfilt[combined_LGR5_barcodes].copy()
nocol_LGR5_unfilt_subset = nocol_unfilt[nocol_LGR5_barcodes].copy()
duodenum_LGR5_unfilt_subset = duo_unfilt[duo_LGR5_barcodes].copy()
# Epithelium
antrum_unfilt_subset = ant_unfilt[antrum_barcodes].copy()
combined_unfilt_subset = combined_unfilt[combined_barcodes].copy()
nocol_unfilt_subset = nocol_unfilt[nocol_barcodes].copy()
duodenum_unfilt_subset = combined_unfilt[duodenum_barcodes].copy()

# Writing the refiltered but not processed files
combined_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_unfilt_subset.h5ad')
antrum_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_unfilt_subset.h5ad')
combined_LGR5_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_LGR5_unfilt_subset.h5ad')
antrum_LGR5_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_LGR5_unfilt_subset.h5ad')
nocol_LGR5_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_LGR5_unfilt_subset.h5ad')
nocol_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_unfilt_subset.h5ad')
duodenum_unfilt_subset.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/duodenum_unfilt_subset.h5ad')

#replace_with_%%_to_restore_cell_breaks Processing and plotting the filtered stuff from raw instead of all the redone stuff
# For the combined
# LGR5
combined_LGR5_refilt_proc = process_for_UMAP(combined_LGR5_unfilt_subset, leiden_res = 0.1)
#sc.pl.umap(combined_LGR5_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 20)
# Epithelium
combined_refilt_proc = process_for_UMAP(combined_unfilt_subset, leiden_res = 0.1)
#sc.pl.umap(combined_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 20)
sc.pl.umap(combined_refilt_proc, color = ['Localization', 'leiden'])
sc.pl.umap(combined_LGR5_refilt_proc, color = ['leiden'])
sc.pl.umap(combined_LGR5_refilt_proc, color = ['Localization'])

#%%
cluster_map = {
    '0' : 'Colon',
    '1' : 'Duodenum',
    '2' : 'Stomach'
    }

map_to_column(data = combined_LGR5_refilt_proc, map_set = cluster_map, column = 'leiden')

# For antrum
# LGR5
antrum_LGR5_refilt_proc = process_for_UMAP(antrum_LGR5_unfilt_subset, leiden_res = 0.2)
antrum_LGR5_refilt_proc.obs['Localization'] = antrum_LGR5_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_LGR5_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(antrum_LGR5_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
# Epithelium
antrum_refilt_proc = process_for_UMAP(antrum_unfilt_subset, leiden_res = 0.3)
antrum_refilt_proc.obs['Localization'] = antrum_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(antrum_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
sc.pl.umap(antrum_refilt_proc, color = ['ANPEP', 'LGR5', 'MUC5AC', 'MUC6', 'MUC2', 'leiden', 'Localization'])



# For nocol
# LGR5
nocol_LGR5_refilt_proc = process_for_UMAP(nocol_LGR5_unfilt_subset, leiden_res = 0.1)
nocol_LGR5_refilt_proc.obs['Localization'] = nocol_LGR5_refilt_proc.obs['Site'].astype(str) + ' ' + nocol_LGR5_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(nocol_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 40)
# Epithelium
nocol_refilt_proc = process_for_UMAP(nocol_unfilt_subset, leiden_res = 0.1)
nocol_refilt_proc.obs['Localization'] = nocol_refilt_proc.obs['Site'].astype(str) + ' ' + nocol_refilt_proc.obs['Patient'].astype(str)
#sc.pl.umap(nocol_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 40)

#sc.pl.violin(antrum_refilt_proc, keys = 'n_genes_by_counts', groupby = 'Patient')
#sc.pl.scatter(antrum_refilt_proc, y = 'n_genes_by_counts', x = 'LGR5', color = 'Patient')
#antrum_refilt_proc.obs['Patient'].value_counts()

end_time = time.time()
print("Script executed in", end_time - start_time, "seconds")
print("Script executed in", (end_time - start_time)/60, "minutes")

#%%
#replace_with_%%_to_restore_cell_breaks Writing the files for volcano plot in R. This is specifically for antrum_LGR5_refilt_proc

leiden_map = {
    '0' : 'Metaplastic antrum',
    '1' : 'Gastric antrum'}

map_to_column(data = antrum_LGR5_refilt_proc, map_set = leiden_map, column = 'leiden')
print(antrum_LGR5_refilt_proc.obs['leiden'])
sc.pl.umap(antrum_LGR5_refilt_proc, color = ['leiden', 'Patient'])
# Calculate diff exp ranking
sc.tl.rank_genes_groups(adata = antrum_LGR5_refilt_proc, groupby = 'leiden', method = 'wilcoxon')
sc.pl.rank_genes_groups(adata = antrum_LGR5_refilt_proc)
sc.pl.dotplot(adata = antrum_LGR5_refilt_proc, groupby = 'leiden', var_names = ['LGR5', 'SMOC2'])
sc.pl.umap(antrum_LGR5_refilt_proc, color = 'Localization')

# Extract the relevant arrays
gene_names = antrum_LGR5_refilt_proc.uns['rank_genes_groups']['names']
logfoldchanges = antrum_LGR5_refilt_proc.uns['rank_genes_groups']['logfoldchanges']
pvals_adj = antrum_LGR5_refilt_proc.uns['rank_genes_groups']['pvals_adj']

# Since you have two groups, you can loop or manually index each group
# Extracting DGE data from the object

dataframes = {}
for group in ['Metaplastic antrum', 'Gastric antrum']:
    # Extract information for each group
    names = gene_names[group]
    lfc = logfoldchanges[group]
    pval_adj = pvals_adj[group]

    # Create DataFrame
    df = pd.DataFrame({
        'Gene Names': names,
        'Log Fold Change': lfc,
        'Adjusted P-Value': pval_adj
    }).set_index('Gene Names')

    dataframes[group] = df

# Now you have two DataFrames in the `dataframes` dict, one for each group
# Access them like this:
control_ant = dataframes['Gastric antrum']
metaplastic_ant = dataframes['Metaplastic antrum']

control_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/control_ant.csv')
metaplastic_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/metaplastic_ant.csv')


#%%
# Writing the refiltered and processed files
combined_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_refilt_proc.h5ad')
antrum_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_refilt_proc.h5ad')
combined_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/combined_LGR5_refilt_proc.h5ad')
antrum_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/antrum_LGR5_refilt_proc.h5ad')
nocol_LGR5_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_LGR5_refilt_proc.h5ad')
nocol_refilt_proc.write_h5ad('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/refiltering from raw and reprocessing/nocol_refilt_proc.h5ad')


#replace_with_%%_to_restore_cell_breaks
sc.pl.umap(antrum_refilt_proc, color = ['ANPEP', 'MUC2', 'LGR5', 'MKI67', 'leiden', 'Localization'])

#replace_with_%%_to_restore_cell_breaks
end_time = time.time()
print("Script executed in ", (end_time - start_time)/60, "minutes")
print("Script executed in ", end_time - start_time, "seconds")

#%%
antrum_ep_LGR5.obs['Patient'].value_counts()
antrum_ep_MKI67.obs['Patient'].value_counts()
antrum_epithelium.obs['Patient'].value_counts()

duodenum_epithelium.obs['Patient'].value_counts()
duo_ep_LGR5.obs['Patient'].value_counts()
duo_ep_MKI67.obs['Patient'].value_counts()
#%% Dotplot
# Assuming the gene ranking has already been performed and is stored in antrum_LGR5_refilt_proc
ranked_genes = antrum_LGR5_refilt_proc.uns['rank_genes_groups']

# Extract the top 20 genes for the first group
top_n = 20
groups = ranked_genes['names'].dtype.names  # Get the cluster names

group1 = groups[0]  # Get the name of the first group
group2 = groups[1]  # Get the name of the second group

top_genes_group1 = ranked_genes['names'][group1][:top_n]
top_genes_group2 = ranked_genes['names'][group2][:top_n]

# Combine the top genes in the specified order
ordered_genes = list(top_genes_group2) + list(reversed(top_genes_group1))

# Reverse the order of groups on the Y axis
reversed_groups = list(reversed(antrum_LGR5_refilt_proc.obs['leiden'].cat.categories))

# Plot the combined top genes as a dotplot with reversed Y-axis order
sc.pl.dotplot(antrum_LGR5_refilt_proc, ordered_genes, groupby='leiden', standard_scale='var', categories_order=reversed_groups)

#%% Additional plotting
sc.pl.umap(antrum_LGR5_refilt_proc, color = 'leiden', size = 250)
sc.pl.umap(antrum_LGR5_refilt_proc, color = 'Patient', size = 250)
sc.pl.umap(combined_LGR5_refilt_proc, color = 'Localization', size = 30)

#%% Testing wnt
# Calculate gene ranking
sc.tl.rank_genes_groups(adata = antrum_LGR5_refilt_proc, groupby = 'leiden', method = 'wilcoxon')
inspect_wnt2 = ['WNT1', 'WNT2B', 'WNT3A', 'WNT4', 'WNT6', 'WNT9A', 'WNT10B', 'WNT11']
sc.pl.umap(antrum_epithelium, color = inspect_wnt2)
sc.pl.umap(combined_epithelium, color = inspect_wnt2)
sc.pl.violin(adata = antrum_epithelium, keys = inspect_wnt2, groupby = 'Patient')
sc.pl.dotplot(adata = antrum_epithelium, var_names = inspect_wnt2, groupby = 'Patient')
sc.pl.violin(adata = antrum_epithelium, keys = 'CTNNB1', groupby = 'Patient')

#%%



# Extract the ranking results
gene_rankings = antrum_LGR5_refilt_proc.uns['rank_genes_groups']

# Get the top 50 genes for patients
top_genes_patient = gene_rankings['names']['Metaplastic antrum'][:50]

# Get the top 50 genes for controls
top_genes_control = gene_rankings['names']['Gastric antrum'][:50]

# Print the top 50 genes for each group
print("Top 50 genes for patients:")
print(top_genes_patient)

print("\nTop 50 genes for controls:")
print(top_genes_control)