# This script is meant for the processing of different files into a format that's ready for filtering by expression
# and downstream analyses
# This will read the files generated by "processing script.py"

# Import packages
import scanpy as sc
import anndata as ad
import pandas as pd

#_cell_break_replace_with_%%_to_restore_cells function definitions
def process_for_UMAP(data, normed = 0, leiden_res = 0.8):
    adata = data.copy() # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = 2000) # Filter cells based on minimum number of RNA reads
    sc.pp.filter_cells(adata, min_genes= 500) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = 3) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['predicted_doublets'] == False]
    adata_prefilt = adata_prefilt[adata_prefilt.obs['n_genes_by_counts'] < 8000]
    if not normed:
        adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < 50] # Filter on the cells with fewer than 10% mitochondrial reads
    else:
        adata_filt = adata_prefilt
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    print("################# Filtering on variable genes ... #################")
    adata_filt = adata_filt[:, adata_filt.var.highly_variable] # Filter on genes that are highly variable
    print("################# Regressing ... #################")
    sc.pp.regress_out(adata_filt, ['total_counts', 'pct_counts_mt']) # Regression. Not sure what that is.
    print("################# Scaling ... #################")
    sc.pp.scale(adata_filt, max_value = 10) # Scale the data
    print("################# Calculating PCA ... #################")
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt)
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt)
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res)
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt)
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga #################")
    sc.tl.umap(adata_filt, init_pos='paga')
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt)
    print("#################Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden'])
    return adata_filt

def recalc_UMAP(data, leiden_res = 0.8):
    adata_filt = data
    sc.tl.pca(adata_filt, svd_solver='arpack') # Compute PCA
    print("################# Calculating tSNE ... #################")
    sc.tl.tsne(adata_filt)
    print("################# Calculating neighbors ... #################")
    sc.pp.neighbors(adata_filt)
    print("################# Calculating Leiden ... #################")
    sc.tl.leiden(adata_filt, resolution = leiden_res)
    print("################# Calculating PAGA ... #################")
    sc.tl.paga(adata_filt)
    print("################# Plotting PAGA ... #################")
    sc.pl.paga(adata_filt, plot = 1)  # remove `plot=False` if you want to see the coarse-grained graph
    print("################# Calculating UMAP init_pos = paga#################")
    sc.tl.umap(adata_filt, init_pos='paga')
    print("################# Calculating UMAP ... #################")
    sc.tl.umap(adata_filt)
    print("################# Plotting UMAP ... #################")
    sc.pl.umap(adata_filt, color = ['leiden'])
    return adata_filt

def process_until_norm(data, cells):
    adata = data.copy() # This is to avoid writing into the file that's entered as an argument
    print("################# Filtering ... #################")
    sc.pp.filter_cells(adata, min_counts = 2000) # Filter cells based on number of RNA reads
    sc.pp.filter_cells(adata, min_genes= 500) # Filter cells based on the number of recognized genes
    sc.pp.filter_genes(adata, min_cells = 3) # Filter genes based on the minimum number of cells expressing it
    adata_prefilt = adata[adata.obs['predicted_doublets'] == False]
    adata_filt = adata_prefilt[adata_prefilt.obs['pct_counts_mt'] < 50] # Filter on the cells with fewer than 10% mitochondrial reads
    adata_prefilt = adata_prefilt[adata_prefilt.obs['n_genes_by_counts'] < 8000]
    print("################# Normalizing ... #################")
    sc.pp.normalize_total(adata_filt, target_sum=1e4) # Normalize
    print("################# Log scaling ... #################")
    sc.pp.log1p(adata_filt) # Log scaling
    print("################# Finding variable genes ... #################")
    sc.pp.highly_variable_genes(adata_filt, min_mean = 0.0125, max_mean = 3, min_disp = 0.5) # Compute differentially expressed genes within the sample
    print("################# Saving raw data ... #################")
    adata_filt.raw = adata_filt # Store the raw files in its own layer
    return adata_filt
    

def isolate_cells_by_gene(data, gene, threshold):
    # Now subset_ant_mt_filt contains only the highly variable genes
    data_subset = data[data[:, gene].X > threshold]
    
    return data_subset

# This function filters the leiden clusters that are positivefor the gene you specify
# It assumes that you already did the differential expression analysis. 
# diff is boolean specifying if differential expresion is already done
# threshold is the threshold of expression
def filter_clusters_by_gene(data, gene, threshold = 0.5):
    # Load your AnnData object
    adata = data.copy()
    sc.tl.rank_genes_groups(adata, groupby='leiden', method = 'wilcoxon')
    # Extract the DataFrame for the differential expression results
    de_results = pd.DataFrame(adata.uns['rank_genes_groups']['names'])
    # Define a threshold for significant expression (adjust as needed)
    expression_threshold = threshold
    # Find clusters with significant EPCAM expression
    significant_clusters = []
    for cluster in de_results.columns:
        gene_presence = de_results[cluster].str.contains(gene)
        gene_expression = adata.uns['rank_genes_groups']['logfoldchanges'][cluster][gene_presence]
        if any(gene_expression >= expression_threshold):
            significant_clusters.append(cluster)
    # Subset the data to include only cells from the significant clusters
    adata_subset = adata[adata.obs['leiden'].isin(significant_clusters)].copy()
    return adata_subset


#_cell_break_replace_with_%%_to_restore_cells Environment settings and misc variables
sc.settings.verbosity = 3
sc.set_figure_params(dpi = 600)

inspect_stem = ['LGR5', 'MKI67', 'TNFRSF19', 'BMI1', 'LRIG1', 'leiden', 'Localization']
global_res = 0.5
LGR5_threshold = 0.5
diff_exp_method = 'wilcoxon'

#_cell_break_replace_with_%%_to_restore_cells reading the already processed files
combined_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_proc.h5ad')
combined_nocol_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_nocol_proc.h5ad')
antrum_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/antrum_proc.h5ad')
combined_control_proc = sc.read('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/combined_control_proc.h5ad')

#_cell_break_replace_with_%%_to_restore_cells Gating on epithelial cells in the fully-combined file
combined_epithelium = filter_clusters_by_gene(data = combined_proc, gene = 'EPCAM')
antrum_epithelium = filter_clusters_by_gene(data = antrum_proc, gene = 'EPCAM')
nocol_epithelium = filter_clusters_by_gene(data = combined_nocol_proc, gene = 'EPCAM')
combined_control_epithelium = filter_clusters_by_gene(data = combined_control_proc, gene = 'EPCAM')

#_cell_break_replace_with_%%_to_restore_cells QC check plots
sc.pl.umap(combined_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')
sc.pl.umap(antrum_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')
sc.pl.umap(nocol_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')
sc.pl.umap(combined_control_epithelium, color = ['leiden', 'Localization'], title = 'combined_epithelium QC')


#_cell_break_replace_with_%%_to_restore_cells Relabeling Localization
# Preparing the index 
localization_mapping = {
    'Antrum GI6253' : 'Control Antrum',
    'Antrum P26' : 'P1 Antrum',
    'Colon GI6253' : 'Control Colon',
    'Colon P26' : 'P1 Colon',
    'Duodenum GI6253' : 'Control Duodenum',
    'Duodenum P26' : 'P1 Duodenum'
}

# Doing the mapping
# The combined dataset
combined_epithelium.obs['Localization_old'] = combined_epithelium.obs['Localization']
combined_epithelium.obs['Localization'] = combined_epithelium.obs['Localization'].map(localization_mapping)
print(combined_epithelium.obs['Localization'])
print(combined_epithelium.obs['Localization_old'])

# The antrum dataset
antrum_epithelium.obs['Localization_old'] = antrum_epithelium.obs['Localization']
antrum_epithelium.obs['Localization'] = antrum_epithelium.obs['Localization'].map(localization_mapping)
print(antrum_epithelium.obs['Localization'])
print(antrum_epithelium.obs['Localization_old'])

# The combined no colon dataset
nocol_epithelium.obs['Localization_old'] = nocol_epithelium.obs['Localization']
nocol_epithelium.obs['Localization'] = nocol_epithelium.obs['Localization'].map(localization_mapping)
print(nocol_epithelium.obs['Localization'])
print(nocol_epithelium.obs['Localization_old'])

# The combined control only
combined_control_epithelium.obs['Localization_old'] = combined_control_epithelium.obs['Localization']
combined_control_epithelium.obs['Localization'] = combined_control_epithelium.obs['Localization'].map(localization_mapping)
print(combined_control_epithelium.obs['Localization'])
print(combined_control_epithelium.obs['Localization_old'])

#_cell_break_replace_with_%%_to_restore_cells Filtering and combining the LGR5 and MKI67 cells from all the different epithelial combinations
# Filtering combined
combined_ep_LGR5 = isolate_cells_by_gene(data = combined_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_ep_MKI67 = isolate_cells_by_gene(data = combined_epithelium, gene = 'MKI67', threshold = 0.5)
combined_nu_LGR5MKI67 = ad.concat([combined_ep_LGR5, combined_ep_MKI67], join = 'outer')
combined_LGR5MKI67 = combined_nu_LGR5MKI67[~combined_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering antrum
antrum_ep_LGR5 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
antrum_ep_MKI67 = isolate_cells_by_gene(data = antrum_epithelium, gene = 'MKI67', threshold = 0.5)
antrum_nu_LGR5MKI67 = ad.concat([antrum_ep_LGR5, antrum_ep_MKI67], join = 'outer')
antrum_LGR5MKI67 = antrum_nu_LGR5MKI67[~antrum_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined no colon
nocol_ep_LGR5 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
nocol_ep_MKI67 = isolate_cells_by_gene(data = nocol_epithelium, gene = 'MKI67', threshold = 0.5)
nocol_nu_LGR5MKI67 = ad.concat([nocol_ep_LGR5, nocol_ep_MKI67], join = 'outer')
nocol_LGR5MKI67 = nocol_nu_LGR5MKI67[~nocol_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()

# Filtering combined control only
combined_control_ep_LGR5 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'LGR5', threshold = LGR5_threshold)
combined_control_ep_MKI67 = isolate_cells_by_gene(data = combined_control_epithelium, gene = 'MKI67', threshold = 0.5)
combined_control_nu_LGR5MKI67 = ad.concat([combined_control_ep_LGR5, combined_control_ep_MKI67], join = 'outer')
combined_control_LGR5MKI67 = combined_control_nu_LGR5MKI67[~combined_control_nu_LGR5MKI67.obs['cellbarcode'].duplicated(keep = 'first')].copy()


#_cell_break_replace_with_%%_to_restore_cells Recalculating UMAPs of the different combinations
combined_LGR5_recalc = recalc_UMAP(data = combined_ep_LGR5, leiden_res = 0.1)
combined_MKI67_recalc = recalc_UMAP(data = combined_ep_MKI67, leiden_res = 0.1)

antrum_LGR5_recalc = recalc_UMAP(data = antrum_ep_LGR5, leiden_res = 0.1)
antrum_MKI67_recalc = recalc_UMAP(data = antrum_ep_MKI67, leiden_res = 0.1)

nocol_LGR5_recalc = recalc_UMAP(data = nocol_ep_LGR5, leiden_res = 0.5)
nocol_MKI67_recalc = recalc_UMAP(data = nocol_ep_MKI67, leiden_res = 0.5)

combined_control_LGR5_recalc = recalc_UMAP(data = combined_control_ep_LGR5, leiden_res = 0.5)
combined_control_MKI67_recalc = recalc_UMAP(data = combined_control_ep_MKI67, leiden_res = 0.5)

combined_LGR5MKI67_recalc = recalc_UMAP(data = combined_LGR5MKI67, leiden_res = 0.1)
nocol_LGR5MKI67_recalc = recalc_UMAP(data = nocol_LGR5MKI67, leiden_res = 0.1)
antrum_LGR5MKI67_recalc = recalc_UMAP(data = antrum_LGR5MKI67, leiden_res = 0.05)
combined_control_LGR5MKI67_recalc = recalc_UMAP(data = combined_control_LGR5MKI67, leiden_res = 0.1)

# =============================================================================
print("######################################################################")
print("####   END OF PROCESSING. START MESSING AROUND WITH ANALYSIS.     ####")
print("######################################################################")
# =============================================================================
#%% Checking all the different QC metrics in obs post processing just to make sure things are proper
checking = ['Biopsies', 'Inflammation', 'pct_counts_mt', 'pct_counts_rp', 'pct_counts_hb', 'n_genes', 'doublet_scores', 'Localization']
str(combined_epithelium)
sc.pl.umap(combined_LGR5_recalc, color = checking) 
sc.pl.umap(antrum_LGR5_recalc, color = checking) 
sc.pl.umap(combined_epithelium, color = checking)
sc.pl.umap(combined_epithelium, color = checking)
sc.pl.umap(nocol_epithelium, color = 'Localization', size = 10)
print(antrum_epithelium.obs['Patient'].value_counts())
 
#%%
#_cell_break_replace_with_%%_to_restore_cells Plotting the UMAPs from above to check
sc.pl.umap(combined_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined LGR5')
sc.pl.umap(combined_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined MKI67')

sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5')
sc.pl.umap(antrum_MKI67_recalc, color = inspect_stem, size = 90, title = 'antrum MKI67')

sc.pl.umap(nocol_LGR5_recalc, color = inspect_stem, size = 30, title = 'nocol LGR5')
sc.pl.umap(nocol_MKI67_recalc, color = inspect_stem, size = 30, title = 'nocol MKI67')

sc.pl.umap(combined_control_LGR5_recalc, color = inspect_stem, size = 15, title = 'combined_control LGR5')
sc.pl.umap(combined_control_MKI67_recalc, color = inspect_stem, size = 10, title = 'combined_control MKI67')

sc.pl.umap(combined_LGR5MKI67_recalc, color = inspect_stem, size = 5, title = 'LGR5/combined prolif')
sc.pl.umap(antrum_LGR5MKI67_recalc, color = inspect_stem, size = 60, title = 'LGR5/antrum prolif')
sc.pl.umap(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')
sc.pl.tsne(nocol_LGR5MKI67_recalc, color = inspect_stem, size = 10, title = 'LGR5/nocol prolif')

#_cell_break_replace_with_%%_to_restore_cells Inspecting the clusters vs localization to check
sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined LGR5')
sc.pl.umap(combined_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined MKI67')

sc.pl.umap(antrum_LGR5_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum LGR5')
sc.pl.umap(antrum_MKI67_recalc, color = ['leiden', 'Localization'], size = 90, title = 'antrum MKI67')

sc.pl.umap(nocol_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol LGR5')
sc.pl.umap(nocol_MKI67_recalc, color = ['leiden', 'Localization'], size = 30, title = 'nocol MKI67')

sc.pl.umap(combined_control_LGR5_recalc, color = ['leiden', 'Localization'], size = 15, title = 'combined_control LGR5')
sc.pl.umap(combined_control_MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'combined_control MKI67')

sc.pl.umap(combined_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined prolif')
sc.pl.umap(antrum_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 60, title = 'LGR5/antrum prolif')
sc.pl.umap(nocol_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 10, title = 'LGR5/nocol prolif')
sc.pl.umap(combined_control_LGR5MKI67_recalc, color = ['leiden', 'Localization'], size = 5, title = 'LGR5/combined_control prolif')


#_cell_break_replace_with_%%_to_restore_cells mapping for antrum LGR5 
sc.pl.umap(antrum_LGR5_recalc, color = ['leiden'], size = 70, title = 'antrum LGR5')
sc.pl.umap(antrum_LGR5_recalc, color = ['Localization'], size = 70, title = 'antrum LGR5')

# Define a dictionary mapping the old cluster numbers to the new labels
ant_LGR5_mapping = {
    '0' : "Gastric antrum",
    '1' : "Metaplastic antrum"
}

# Convert the cluster numbers to labels using the mapping
antrum_LGR5_recalc.obs['leiden'] = antrum_LGR5_recalc.obs['leiden'].map(ant_LGR5_mapping)

# Rename the leiden column into something that makes sense
# =============================================================================
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)
# =============================================================================

# Print the first few rows to verify the changes
print(antrum_LGR5_recalc.obs.head())

sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'leiden'], size = 150, title = 'LGR5+ cells')
sc.pl.umap(antrum_LGR5_recalc, color = ['HSPA5', 'Localization'], size = 150, title = 'LGR5+ cells')
sc.pl.violin(antrum_LGR5_recalc, keys = 'HSPA5', groupby = 'Localization')


sc.pl.umap(antrum_LGR5_recalc, color = inspect_stem, size = 90, title = 'antrum LGR5 2')
sc.tl.rank_genes_groups(antrum_LGR5_recalc, groupby='leiden', method = 'wilcoxon')
sc.pl.rank_genes_groups(antrum_LGR5_recalc, n_genes=25)

sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'AQP5', 'SLC39A5', 'leiden', 'Localization'], size = 90)

sc.pl.umap(antrum_LGR5_recalc, color = 'leiden', size = 200)
sc.pl.umap(antrum_LGR5_recalc, color = 'Localization', size = 200)
sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'leiden'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells
sc.pl.umap(antrum_LGR5_recalc, color = ['MUC1', 'VSIG2', 'AQP5', 'CD59', 'CYSTM1', 'LGR5'], size = 200) # plot the candidate surface markers for the non-metaplastic stem cells

sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
sc.pl.umap(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)

sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'Localization'], size = 200)
sc.pl.tsne(antrum_LGR5_recalc, color = ['CLDN15', 'SLC39A5', 'EPHB2', 'CLDN7', 'CLDN3', 'MUC3A', 'AQP1', 'LGR5'], size = 200)


#_cell_break_replace_with_%%_to_restore_cells mapping for combined MKI67 
sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 5, title = 'combined MKI67')
sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 5, title = 'combined MKI67')

# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "?"
}

# Convert the cluster numbers to labels using the mapping
combined_MKI67_recalc.obs['leiden'] = combined_MKI67_recalc.obs['leiden'].map(cluster_mapping)

# Optionally, if you want to rename the column to reflect the new labels
combined_MKI67_recalc.obs['leiden'].name = 'Cell Type'

# Print the first few rows to verify the changes
print(combined_MKI67_recalc.obs.head())

sc.pl.umap(combined_MKI67_recalc, color = ['leiden'], size = 7, title = 'MKI67+ cells')
sc.pl.umap(combined_MKI67_recalc, color = ['Localization'], size = 7, title = 'MKI67+ cells')
sc.pl.violin(combined_MKI67_recalc, keys = 'HSPA5', groupby = 'Localization', rotation = 90)

#_cell_break_replace_with_%%_to_restore_cells mapping for combined LGR5 
sc.pl.umap(combined_LGR5_recalc, color = ['leiden'], size = 15, title = 'combined LGR5')
sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 15, title = 'combined LGR5')

# Define a dictionary mapping the old cluster numbers to the new labels
cluster_mapping = {
    '0' : "Colon",
    '1' : "Duodenum",
    '2' : "Antrum",
    '3' : "3"
}

# Convert the cluster numbers to labels using the mapping
combined_LGR5_recalc.obs['leiden'] = combined_LGR5_recalc.obs['leiden'].map(cluster_mapping)

# Rename the leiden column into something that makes sense
# antrum_LGR5_recalc.obs.rename(columns={'leiden': 'Cell Type'}, inplace=True)


# Print the first few rows to verify the changes
print(combined_LGR5_recalc.obs.head())

sc.pl.umap(combined_LGR5_recalc, color = ['leiden', 'Localization'], size = 30, title = 'LGR5+ cells')
sc.pl.umap(combined_LGR5_recalc, color = ['Localization'], size = 30, title = 'LGR5+ cells')

#_cell_break_replace_with_%%_to_restore_cells test cells
sc.pl.umap(combined_LGR5MKI67_recalc, color = ['HSPA5', 'MKI67', 'LGR5', 'leiden', 'Localization'], size = 5)
separated_combo = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].copy()
separated_combo_2 = combined_LGR5MKI67_recalc[combined_LGR5MKI67_recalc.obs['Patient'] == 'GI6253'].copy()
sc.pl.umap(separated_combo, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
sc.pl.scatter(separated_combo, x = 'MKI67', y = 'HSPA5', size = 90, color = 'LGR5')
sc.pl.scatter(separated_combo, x = 'LGR5', y = 'HSPA5', size = 90, color = 'MKI67')
sc.pl.scatter(separated_combo, x = 'LGR5', y = 'MKI67', size = 90, color = 'HSPA5')

sc.pl.violin(separated_combo, keys = 'HSPA5', groupby = 'Site')
sc.pl.violin(separated_combo_2, keys = 'HSPA5', groupby = 'Site')

sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'MKI67', y = 'HSPA5', size = 90, color = 'Localization')
sc.pl.scatter(combined_LGR5MKI67_recalc, x = 'LGR5', y = 'HSPA5', size = 90, color = 'Localization')

print(separated_combo.obs['Localization'])

#_cell_break_replace_with_%%_to_restore_cells Test cell 2

sc.pl.umap(combined_LGR5MKI67_recalc, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])
indices_of_interest = combined_LGR5MKI67_recalc.obs[combined_LGR5MKI67_recalc.obs['Patient'] == 'P26'].index.copy()
sep = combined_LGR5MKI67_recalc[indices_of_interest]
sc.pl.umap(sep, color = ['MKI67', 'LGR5', 'leiden', 'Localization'])


#_cell_break_replace_with_%%_to_restore_cells Writing the files for volcano plot in R. This is specifically for antrum_LGR5_recalc
# Extract the relevant arrays
gene_names = antrum_LGR5_recalc.uns['rank_genes_groups']['names']
logfoldchanges = antrum_LGR5_recalc.uns['rank_genes_groups']['logfoldchanges']
pvals_adj = antrum_LGR5_recalc.uns['rank_genes_groups']['pvals_adj']

# Since you have two groups, you can loop or manually index each group
# Assuming group names are '0' and '1', adjust accordingly

dataframes = {}
for group in ['Gastric antrum', 'Metaplastic antrum']:
    # Extract information for each group
    names = gene_names[group]
    lfc = logfoldchanges[group]
    pval_adj = pvals_adj[group]

    # Create DataFrame
    df = pd.DataFrame({
        'Gene Names': names,
        'Log Fold Change': lfc,
        'Adjusted P-Value': pval_adj
    }).set_index('Gene Names')

    dataframes[group] = df

# Now you have two DataFrames in the `dataframes` dict, one for each group
# Access them like this:
control_ant = dataframes['Gastric antrum']
metaplastic_ant = dataframes['Metaplastic antrum']

control_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/control_ant.csv')
metaplastic_ant.to_csv('C:/Work cache/py_projs/scRNAseq_AGR2/project data cache/testing integration with separation and the stem cells part 2/saved files/metaplastic_ant.csv')

#_cell_break_replace_with_%%_to_restore_cells Extracting the barcodes of the filtered cells so we can retrieve their raw values

# Start by reading the barcodes
antrum_LGR5_barcodes = antrum_LGR5_recalc.obs_names.tolist()
nocol_LGR5_barcodes = nocol_LGR5_recalc.obs_names.tolist()
combined_LGR5_barcodes = combined_LGR5_recalc.obs_names.tolist()

# Reading the original files
ant_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_antrum.h5ad")
duo_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_duodenum.h5ad")
col_unfilt = sc.read("C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/raw_data/agr2_unfilt_colon.h5ad")
combined_unfilt = ad.concat([ant_unfilt, duo_unfilt, col_unfilt], join = 'outer')
nocol_unfilt = ad.concat([duo_unfilt, ant_unfilt], join = 'outer')

# Subsetting
antrum_unfilt_subset = ant_unfilt[antrum_LGR5_barcodes].copy()
combined_unfilt_subset = combined_unfilt[combined_LGR5_barcodes].copy()
nocol_unfilt_subset = nocol_unfilt[nocol_LGR5_barcodes].copy()

#_cell_break_replace_with_%%_to_restore_cells Processing and plotting the filtered stuff from raw instead of all the resdone stuff
# For the combined
combined_refilt_proc = process_for_UMAP(combined_unfilt_subset, leiden_res = 0.1)
combined_refilt_proc.obs['Localization'] = combined_refilt_proc.obs['Site'].astype(str) + ' ' + combined_refilt_proc.obs['Patient'].astype(str)
sc.pl.umap(combined_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 20)

# For antrum
antrum_refilt_proc = process_for_UMAP(antrum_unfilt_subset, leiden_res = 0.1)
antrum_refilt_proc.obs['Localization'] = antrum_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_refilt_proc.obs['Patient'].astype(str)
sc.pl.umap(antrum_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
sc.tl.rank_genes_groups(antrum_refilt_proc, groupby='leiden', method = 'wilcoxon')
sc.pl.rank_genes_groups(antrum_refilt_proc, n_genes=25)

antrum_refilt_proc = process_for_UMAP(antrum_unfilt_subset, leiden_res = 0.5)
antrum_refilt_proc.obs['Localization'] = antrum_refilt_proc.obs['Site'].astype(str) + ' ' + antrum_refilt_proc.obs['Patient'].astype(str)
sc.pl.umap(antrum_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 150)
sc.tl.rank_genes_groups(antrum_refilt_proc, groupby='leiden', method = 'wilcoxon')
sc.pl.rank_genes_groups(antrum_refilt_proc, n_genes=25)

# For nocol
nocol_refilt_proc = process_for_UMAP(nocol_unfilt_subset, leiden_res = 0.1)
nocol_refilt_proc.obs['Localization'] = nocol_refilt_proc.obs['Site'].astype(str) + ' ' + nocol_refilt_proc.obs['Patient'].astype(str)
sc.pl.umap(nocol_refilt_proc, color = ['LGR5', 'leiden', 'Localization'], size = 40)

#%% Testing cell
# Currently testing taking the barcodes from the cells I gated on then getting 
combined_ep_LGR5_barcodes = combined_ep_LGR5.obs_names.tolist()
combined_annot = sc.read('C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/Data annotation/Epithelium_all_locations/data_all_locations_epithelium_0223.h5ad')
combined_annot_LGR5 = combined_annot[combined_ep_LGR5_barcodes].copy() # The non-existent barcodes in the annotated dataset will cause an error here
combined_annot_LGR5.obs['Localization'] = combined_annot_LGR5.obs['Site'].astype(str) + ' ' + combined_annot_LGR5.obs['Patient'].astype(str)

antrum_LGR5_calc = process_for_UMAP(combined_annot_LGR5, leiden_res = global_res)
sc.pl.umap(antrum_LGR5_calc, color = inspect_stem, size = 200)

#_cell_break_replace_with_%%_to_restore_cells Test cell part 2
import numpy as np

# Assuming combined_ep_LGR5_barcodes is a list of barcode strings to check.
# combined_annot is your AnnData object containing your annotated data.

# Check which barcodes are present
barcodes_present = np.isin(combined_ep_LGR5_barcodes, combined_annot.obs_names)

# Count matching and non-matching barcodes
num_present = np.sum(barcodes_present)
num_absent = len(combined_ep_LGR5_barcodes) - num_present

# Print results
print(f"Number of barcodes present in combined_annot: {num_present}")
print(f"Number of barcodes absent from combined_annot: {num_absent}")

#%% Testing cell part 3

# Issue right now is that the cells retrieved are too few to do DGE for clustering
# Step 1: Check which barcodes from `combined_ep_LGR5` are present in `combined_annot`
presence_in_combined_annot = [barcode in combined_annot.obs_names for barcode in combined_ep_LGR5.obs_names]
combined_ep_LGR5.obs['presence'] = presence_in_combined_annot

# Step 2: Add this information as a new column in `combined_ep_LGR5.obs`
combined_ep_LGR5.obs['presence'] = combined_ep_LGR5.obs['presence'].astype('category')
sc.pl.umap(combined_ep_LGR5, color = ['presence', 'Localization'])

combined_ep_LGR5_present = combined_ep_LGR5[combined_ep_LGR5.obs['presence'] == True].copy()
present_LGR5_barcodes = combined_ep_LGR5_present.obs_names.tolist()
present_isolation = ant_unfilt[present_LGR5_barcodes].copy()
present_isolation_proc = process_for_UMAP(present_isolation)
sc.pl.umap(present_isolation_proc, color = ['leiden', 'Patient'])

#%% Additional testing for those included and excluded from the annotated files.

#%% Testing cell
# Currently testing taking the barcodes from the cells I gated on then getting 
nocol_epithelium_barcodes = nocol_epithelium.obs_names.tolist()
combined_annot = sc.read('C:/Work cache/Project sync/PhD/Research projects/AGR2 follow-up/Data cache/ssRNAseq/Aline/Data annotation/Epithelium_all_locations/data_all_locations_epithelium_0223.h5ad')
combined_annot_LGR5 = combined_annot[nocol_epithelium_barcodes].copy() # The non-existent barcodes in the annotated dataset will cause an error here
combined_annot_LGR5.obs['Localization'] = combined_annot_LGR5.obs['Site'].astype(str) + ' ' + combined_annot_LGR5.obs['Patient'].astype(str)

antrum_LGR5_calc = process_for_UMAP(combined_annot_LGR5, leiden_res = global_res)
sc.pl.umap(antrum_LGR5_calc, color = inspect_stem, size = 200)

#_cell_break_replace_with_%%_to_restore_cells Test cell part 2
import numpy as np

# Assuming nocol_epithelium_barcodes is a list of barcode strings to check.
# combined_annot is your AnnData object containing your annotated data.

# Check which barcodes are present
barcodes_present = np.isin(nocol_epithelium_barcodes, combined_annot.obs_names)

# Count matching and non-matching barcodes
num_present = np.sum(barcodes_present)
num_absent = len(nocol_epithelium_barcodes) - num_present

# Print results
print(f"Number of barcodes present in combined_annot: {num_present}")
print(f"Number of barcodes absent from combined_annot: {num_absent}")

#%% Testing cell part 3
checking = ['Biopsies', 'Inflammation', 'pct_counts_mt', 'pct_counts_rp', 'pct_counts_hb', 'n_genes', 'doublet_scores', 'Localization']
# Issue right now is that the cells retrieved are too few to do DGE for clustering
# Step 1: Check which barcodes from `nocol_epithelium` are present in `combined_annot`
presence_in_combined_annot = [barcode in combined_annot.obs_names for barcode in nocol_epithelium.obs_names]
nocol_epithelium.obs['presence'] = presence_in_combined_annot

# Step 2: Add this information as a new column in `nocol_epithelium.obs`
nocol_epithelium.obs['presence'] = nocol_epithelium.obs['presence'].astype('category')
sc.pl.umap(nocol_epithelium, color = ['presence', 'Localization'], size = 3)

nocol_epithelium_present = nocol_epithelium[nocol_epithelium.obs['presence'] == True].copy()
present_LGR5_barcodes = nocol_epithelium_present.obs_names.tolist()
present_isolation = ant_unfilt[present_LGR5_barcodes].copy()
present_isolation_proc = process_for_UMAP(present_isolation)
sc.pl.umap(present_isolation_proc, color = ['leiden', 'Patient'])
sc.pl.umap(combined_epithelium, color = checking)
